- 코틀린에서 제네릭 클래스와 함수를 선언하고 사용하는 기본 개념은 자바와 비슷하다.
- 실제화한 타입 파라미터를 사용하면 인라인 함수 호출에서 타입 인자로 쓰인 구체적인 타입을 실행 시점에 알 수 있다. (일반 클래스나 함수의 경우 타입 인자 정보가 실행 시점에 사라지기 때문에 이런 일이 불가능하다.)
- `List<Any>`를 인자로 받는 함수에게 `List<Int>` 타입 값을 전달할 수 있을지 여부를 **선언 지점 변성**을 통해 지정할 수 있다.
- 자바의 **와일드카드**는 코틀린 **선언 지점 변성**과 같은 역할을 한다.

# 1️⃣ 제네릭 타입 파라미터

- 제네릭스를 사용하면 타입 파라미터를 받는 타입을 정의할 수 있다.
- 제네릭 타입의 인스턴스를 만드려면 타입 파라미터를 구체적인 타입 인자로 치환해야 한다.
- 예를 들어 Map 클래스는 키 타입과 값 타입을 타입 파라미터로 받으므로 `Map<K,V>`가 된다. 이런 제네릭 클래스에 `Map<String, Person>`처럼 구체적인 타입을 타입 인자로 넘기면 인스턴스화할 수 있다.
- 참고로 `val readers = mutableListOf(”string”)` 처럼 컴파일러가 추론할 수 있으면 인스턴스화가 가능하다.

<aside>
💡 자바와 달리 코틀린에서는 제네릭 타입의 타입 인자를 프로그래머가 명시하거나 컴파일러가 추론할 수 있어야 한다.

</aside>

## 1) 제네릭 함수와 프로퍼티

- 컬렉션을 다루는 라이브러리 함수는 대부분 제네릭 함수다.
- 제네릭 함수를 호출할 때는 반드시 구체적 타입으로 타입 인자를 넘겨야 한다.

**제네릭 함수 호출하기**

```kotlin
/*타입 파라미터 선언*/ /*타입 파라미터가 수신 객체와 반환 타입에 쓰인다.*/
public fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {
    ...
}

val letters = ('a'..'z').toList()
letters.slice(10..13)  // 컴파일러는 여기서 T가 Char라는 사실을 추론한다.
```

**제네릭 고차 함수 호출하기**

```kotlin
public inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {
    return filterTo(ArrayList<T>(), predicate)
}

val authors = listOf("a", "b")
val readers = listOf("c", "d")
authors.filter { it !in readers }
```

- 람다 파라미터에 대해 자동으로 반들어진 변수 it의 타입은 T라는 제네릭 타입이다.
- 컴파일러는 filter가 List<T> 타입의 리스트에 대해 호출될 수 있다는 사실과 filter의 수신 객체인 reader의 타입이 List<String>이라는 사실을 알고 T가 String이라는 사실을 추론한다.

**제네릭 확장 프로퍼티**

```kotlin
val <T> List<T>.penultimate: T
    get() = this[size - 1]

**val <T> x: T = TODO() // 컴파일 에러**
```

- 참고로 일반(확장이 아닌) 프로퍼티는  타입 파라미터를 가질 수 없다. 클래스 프로퍼티에 여러 타입 값을 저장한다는 건 말이 되지 않는다.

## 2) 제네릭 클래스 선언

- 자바와 마찬가지로 코틀린에서도 타입 파라미터를 넣은 꺾쇠 기호(<>)를 클래스(또는 인터페이스) 이름 뒤에 붙이면 클래스를 제네릭하게 만들 수 있다.

```kotlin
interface GenericList<T> {  // T라는 타입 파라미터를 정의한다.
    operator fun get(index: Int): T   // 인터페이스 안에서 T를 일반 타입처럼 사용할 수 있다.
}
```

## 3) 타입 파라미터 제약

- 타입 파라미터 제약은 클래스나 함수에 사용할 수 있는 타입 인자를 제한하는 기능이다.
- 어떤 타입을 제네릭 타입의 타입 파라미터에 대한 상한으로 지정하면 그 제네릭 타입을 인스턴스화할 때 사용하는 타입 인자는 반드시 그 상한 타입이거나 그 상한 타입의 하위 타입이어야 한다.
    
    ```kotlin
    fun <T : Number> List<T>.sum(): T
    ```
    

**타입 파라미터에 대해 둘 이상의 제약**

```kotlin
fun <T> ensureTrailingPeriod(seq: T)
    where T : CharSequence, T : Appendable {
    ...
}
```

- 이 예제는 타입 인자가 CharSequence와 Appendable 인터페이스를 반드시 구현해야 한다는 사실을 표현한다.

## 4) 타입 파라미터를 널이 될 수 없는 타입으로 한정

- 아무런 상한을 정하지 않은 타입 파라미터는 결과적으로 Any?를 상한으로 정한 파라미터와 같다.
- 널이 될 수 없는 타입으로 한정하려면 아래와 같이 하면된다. 물론 다른 클래스를 사용해도 된다.

```kotlin
class Processor<T : Any> {
		...
}
```

---

# 2️⃣ 실행 시 제네릭스의 동작: 소거된 타입 파라미터와 실체화된 타입 파라미터

- JVM의 제네릭스는 보통 타입 소거를 사용해 구현된다.
    - 이는 실행 시점에 제네릭 클래스의 인스턴스에 타입 인자 정보가 들어있지 않다는 뜻이다.
    - 코틀린에서는 inline으로 만들면 타입 인자가 지워지지 않게 할 수 있다. (실체화라고 부른다.)

## 1) 실행 시점의 제네릭: 타입 검사와 캐스트

- 자바와 마찬가지로 코틀린 제네릭 타입 인자 정보는 런타임에 지워진다(타입 소거). 이는 제네릭 클래스 인스턴스가 그 인스턴스를 생성할 때 쓰인 타입 인자에 대한 정보를 유지하지 않는다는 뜻이다.
- 예를 들어 LIst<String> 객체를 만들고 그 안에 문자열을 여럿 넣더라도 실행 시점에는 그 객체를 오직 List로만 볼 수 있다. 실행 시점에는 알 수 없다.

```kotlin
val list1: List<String> = ...
val list2: List<Int> = ...
```

- 컴파일러는 두 리스트를 서로 다른 타입으로 인식한다.
- 그러나 실행 시점에는 그 둘은 완전히 같은 타입(List)의 객체이다.
- 그럼에도 불구하고 보통은 List<String>와 List<Int>로 가정할 수 있는데, 이는 컴파일러가 타입 인자를 알고 올바른 타입의 값만 각 리스트에 넣도록 보장해주기 때문이다.

**타입 소거로 인해 생기는 한계**

- 타입 인자를 따로 저장하지 않기 때문에 실행 시점에 타입 인자를 검사할 수 없다.
    - 일반적으로 말하자면 is 검사에서 타입 인자로 지정한 타입을 검사할 수 없다.
    
    ```kotlin
    if(value is List<String>) { ... }
    ERROR: Cannot check for instance of erased type
    ```
    

**타입 소거의 장점**

- 저장해야 하는 타입 정보의 크기가 줄어들어서 전반적인 메모리 사용량이 줄어든다.

**스타 프로젝션**

- 코틀린에서는 타입 인자를 명시하지 않고 제네릭 타입을 사용할 수 없는데, 어떻게 어떤 값이 리스트라는 사실을 확인할 수 있을까?
- 스타 프로젝션(`*`)을 사용하면 된다.

```kotlin
if(value is List<*>) { ... }
```

- 이 녀석은 뒤에서 자세히 다룰 것이다.

**제네릭 타입으로 타입 캐스팅하기**

```kotlin
fun printSum(c: Collection<*>) {
    val inList = c as? List<Int> ?: throw IllegalArgumentException()
    println(inList.sum())
}

printSum(listOf(1, 2, 4))   // 정상 출력
printSum(listOf("1", "2"))  // ClassCastException 발생
```

- as나 as? 캐스팅에도 제네릭 타입을 사용할 수 있다.
    - 캐스팅 관련 경고를 하고 문제없이 컴파일된다.
- 하지만 실행 시점에는 제네릭 타입의 인자를 알 수 없으므로 캐스팅은 항상 **성공**한다. 따라서 `IllegalArgumentException`은 발생하지 않는다.
    - 위 코드 inList.sum() 메서드를 수행하면서 `ClassCastException`이 발생한다.

**알려진 타입 인자를 사용해 타입 검사하기**

```kotlin
fun printSum(c: Collection<Int>) {
    if(c is List<Int>) {
				println(inList.sum())
		}
}
```

- 코틀린 컴파일러는 컴파일 시점에 타입 정보가 주어진 경우에는 is 검사를 수행하게 허용할 수 있을 정도로 똑똑하다.

## 2) 실체화한 타입 파라미터를 사용한 함수 선언

- 코틀린 제네릭 타입의 타입 인자 정보는 실행 시점에 지워진다.
- 제네릭 함수가 호출되도 그 함수의 본문에서는 호출 시 쓰인 타입 인자를 알 수 없다.
    
    ```kotlin
    fun <T> inA(value: Any) = value is T
    ERROR: Cannot check for instance of erased type
    ```
    

이런 제약을 피할 수 있는 경우가 하나 있다.

인라인 함수의 타입 파라미터는 실체화되므로 실행 시점에 인라인 함수의 타입 인자를 알 수 있다.

```kotlin
inline fun <reified T> isA(value: Any) = value is T

println(isA<String>("abc"))
```

- 타입 파라미터를 reified로 지정하면 value의 타입이 T의 인스턴스인지를 실행 시점에 검사할 수 있다.

<aside>
💡 **인라인 함수에서만 실체화된 타입 인자를 쓸 수 있는 이유**
컴파일러는 인라인 함수의 본문을 구현한 바이트코드를 그 함수가 호출되는 모든 지점에 삽입한다. 
따라서 컴파일러는 실체화한 타입 인자를 사용해 인라인 함수를 호출하는 각 부분의 정확한 타입 인자를 알 수 있다. (구체적인 클래스를 참조하는 바이트코드를 생성해 삽입할 수 있다.)
이러한 이유 때문에 reified 타입을 사용하는 inline 함수는 자바 코드에서 호출할 수 없다.

</aside>

- 인라인 함수를 사용하는 이유 중 하나는 실체화한 타입 파라미터를 사용하기 위함이다.
- 인라인 함수의 성능을 좋게 하려면 크기를 계속 관찰해야 한다. 실체화한 타입에 의존하지 않는 부분을 별도의 일반 함수로 뽑아내는 편이 낫다.
- 인라이닝을 하기 싫으나 실체화한 타입 파라미터를 사용하고 싶으면 noliline을 사용하자.

## 3) 실체화한 타입 파라미터의 제약

- 실체화한 타입 파라미터는 몇 가지 제약이 있다.

**실체화한 타입 파리미터를 사용할 수 있는 경우**

- 타입 검사와 캐스팅
- 코틀린 리플렉션 API
- 코틀린 타입에 대응하는 java.lang.Class 얻기
- 다른 함수를 호출할 때 타입 인자로 사용

**실체화한 타입 파라미터로 할 수 없는 일**

- 타입 파라미터 클래스의 인스턴스 생성하기
- 타입 파라미터 클래스의 동반 객체 메서드 호출하기
- 실체화한 타입 파라미터를 요구하는 함수를 호출하면서 실체화하지 않은 타입 파라미터로 받은 타입을 타입 인자로 넘기기
- 클래스, 프로퍼티, 인라인 함수가 아닌 함수의 타입 파라미터를 reified로 지정하기

---

# 3️⃣ 변성: 제네릭과 하위 타입

- 변성의 개념은 List<String>과 List<Any>와 같이 기저 타입이 같고 타입 인자가 다른 여러 타입이 서로 어떤 관계가 있는지 설명하는 개념이다.
- 변성을 잘 활용하면 사용에 불편하지 않으면서 타입 안정성을 보장하는 API를 만들 수 있다.

## 1) 변성이 있는 이유: 인자를 함수에 넘기기

- List<Any> 타입의 파라미터를 받는 함수에 List<String>을 넘기면 안전할까?
- String 클래스는 Any를 확장하므로 넘겨도 안전하다.
- 그러나 Any와 String이 List 인터페이스 타입 인자로 들어가는 경우 자신 있게 안정성을 말할 수 없다.
- 이해를 돕기 위해 예제를 살펴보자
    
    ```kotlin
    public interface List<out E> : Collection<E> { .. }
    
    fun main() {
        val list1 = listOf("a", "b")
        printContents(list1)
    }
    
    fun printContents(list: List<Any>) {
        println(list.joinToString())
    }
    ```
    
    - 이 경우는 문자열 리스트도 잘 작동한다. 문자열은 Any 타입이기도 하므로 완전히 안전하다.
    
    ```kotlin
    fun main() {
        val list2 = mutableListOf("a", "b")
        addAnswer(list2)  // 컴파일 에러 발생
    }
    
    fun addAnswer(list: MutableList<Any>) {
        list.add(42)
    }
    ```
    
    - 이 경우는 컴파일 에러가 발생한다.
    - 만약 컴파일 에러가 발생하지 않는다면 addAnswer() 메서드는 정수를 리스트 뒤에 추가할 수 있고, 런타임 시점에 ClassCastException이 발생하게 된다.
    - 이 예제는 MutableList<Any>가 필요한 곳에 MutableList<String>을 넘기면 안 된다는 사실을 보여준다.
- 정리를 하자면 어떤 함수가 리스트의 원소를 추가하거나 변경한다면 타입 불일치가 생길 수 있어서 List<Any> 대신 List<String>을 넘길 수 없다. 하지만 원소 추가나 변경이 없는 경우에는 List<String>을 List<Any> 대신 넘겨도 안전하다.
- 코틀린에서는 리스트의 변경 가능성에 따라 적절한 인터페이스를 선택하면 안전하지 못한 함수 호출을 막을 수 있다.
- 결국 이런 개념은 모든 클래스에 대해 적용된다.

## 2) 클래스, 타입, 하위 타입

### **클래스와 타입**

**클래스**

- 제네릭 클래스가 아닌 클래스에서는 클래스 이름을 바로 타입으로 쓸 수 있다.
- `var x: String`이라고 쓰면 String 클래스의 인스턴스를 저장하는 변수를 정의할 수 있다.
- `var x: String?`처럼 같은 클래스 이름을 널이 될 수 있는 타입에도 쓸 수 있다.
- 이는 모든 코틀린 클래스가 적어도 둘 이상의 타입을 구성할 수 있다는 뜻이다.

**제네릭 클래스**

- 올바른 타입을 얻으려면 제네릭 타입의 타입 파라미터를 구체적인 타입 인자로 바꿔줘야 한다.
- 예를 들어 List는 타입이 아니다.(클래스다.)
- 하지만 타입 인자를 치환한 List<Int>, List<String> 등은 모두 제대로 된 타입이다.
- 제네릭 클래스는 무수히 많은 타입을 만들어 낼 수 있다.

정리하자면 클래스는 적어도 둘 이상의 타입을 구성할 수 있으므로 타입보다 큰 의미라고 생각하면 된다.

### 하위 타입

- 어떤 타입 A의 값이 필요한 모든 장소에 어떤 타입 B를 넣어도 아무 문제가 없다면 타입 B는 타입 A의 하위 타입이다.
- 상위 타입은 하위 타입의 반대다.
- 한 타입이 다른 타입의 하위 타입인지가 왜 중요할까?
    - 컴파일러는 변수 대입이나 함수 인자 전달 시 하위 타입 검사를 매번 수행한다.
        
        ```kotlin
        fun test() {
        		val i = 1
        		val n: Number = i    // Int가 Number의 하위 타입이여서 컴파일된다.
        		
        		fun f(s: String) { ... }
        		f(i)                 // Int가 String의 하위 타입이 아니어서 컴파일되지 않는다.
        }
        ```
        
    - 어떤 값의 타입이 변수 타입의 하위 타입인 경우에만 값을 변수에 대입하게 허용한다.
    - 이 예제에서 변수를 초기화한 i의 Int로 변수의 타입인 Number의 하위 타입이다.
- 간단한 경우 하위 타입은 하위 클래스와 근본적으로 같다.
    - 예를 들어 Int 클래스는 Number의 하위 클래스인 것처럼 하위 타입이기도 하다.
- 다만 널이 될 수 있는 타입은 하위 타입과 하위 클래스가 같지 않다.
    - 널이 될 수 없는 타입은 널이 될 수 있는 타입의 하위 타입이다.
        
        ```kotlin
        val s: String = "abc"
        val t: String? = s // String은 String?의 하위 타입이므로 대입이 가능하다.
        s = t // String?이 상위 타입이므로 대입이 불가능하다.
        ```
        
    - 하지만 두 타입 모두 같은 클래스에 해당한다.
- 제네릭 타입에  대해 이야기할 때 특히 하위 클래스와 하위 타입의 차이가 중요해진다.
    - 앞에서 살펴본 **`List<String> 타입의 값을 List<Any>를 파라미터로 받는 함수에 전달해도 괜찮은가?`** 라는 질문을 하위 타입 관계를 써서 다시 쓰면 **`List<String>은 List<Any>의 하위 타입인가?`**다.
    - MutableList<String>은 MutableList<Any>의 하위 타입이 아니다. 그 반대도 참이 아니다.

### 무공변

- 제네릭 타입을 인스턴스화할 때 타입 인자로 서로 다른 타입이 들어가면, 인스턴스 타입 사이의 하위 타입 관계가 성립하지 않는데 그 제네릭 타입을 **무공변**이라고 한다.
    - MutableList를 예를 들면 A와 B가 서로 다르기만 하면 MutableList<A>는 MutableList<B>의 하위 타입이 아니다.
    - 자바에서는 모든 클래스가 무공변이다. 이건 잠시 뒤에 자세히 알아보자.

## 3) 공변성: 하위 타입 관계를 유지

Producer<T>를 예로 공변성 클래스를 설명하자. A가 B의 하위 타입일 때 Producer<A>가 Producer<B>의 하위 타입이면 Producer는 공변적이다. 이를 하위 타입 관계가 유지된다고 말한다.

코틀린에서 제네릭 클라스가 타입 파라미터에 대해 공변적임을 표시하려면 타입 파라미터 이름 앞에 out을 넣어야 한다. (참고로 위에서 설명한 List 인터페이스도 out이 붙어있다.)

```kotlin
interface Producer<out T> { ... }
```

클래스의 타입 파라미터를 공변적으로 만들면 함수 정의에 사용한 파라미터 타입과 타입 인자의 타입이 정확히 일치하지 않더라도 그 클래스의 인스턴스를 함수 인자나 반환 값으로 사용할 수 있다.

간단한 예제를 살펴보자.

```kotlin
open class Animal {
    fun feed() { ... }
}

class Herd<T : Animal> {
    operator fun get(i: Int): T { ... }
}

fun feedAll(animals: Herd<Animal>) { ... }
```

- Herd 클래스로 표현되는 동물 무리의 사육을 담당하는 함수가 있다고 가정하다.
- Herd 클래스의 타입 파라미터는 그 떼가 어떤 동물 무리인지 알려준다.

```kotlin
class Cat : Animal() {
    fun cleanLitter() { ... }
}

fun takeCareOfCats(cats: Herd<Cat>) {
    for (i in 0 until cats.size) {
				cats[i].cleanLitter()
		    feedAll(cats) // Type mismatch 라는 컴파일 에러가 발생한다.
		}
}
```

feedAll() 메서드에서 컴파일 에러가 발생하는 이유는 Cat은 AnimalHerd<Cat>은 Herd<Animal>의 하위 타입이 아니기 때문이다. 타입 캐스팅을 사용하면 이 문제를 풀 수 있지만 강제 캐스팅, 실수 유발, 코드 장황 등의 문제점이 발생하기 때문에 올바른 방법이 아니다.

가장 좋은 해결방법은 Herd를 공변적인 클래스로 만드는 것이다.

```kotlin
class Herd<out T : Animal> { ... }
```

클래스 멤버를 선언할 때 타입 파라미터를 사용할 수 있는 지점은 모두 인과 아웃 위치로 나뉜다. T라는 타입 파라미터를 선언하고 T를 사용하는 함수가 멤버로 있는 클래스를 생각해보자.

```kotlin
interface Transformer<T> {
		fun transform(t: T): T
						 /*인 위치*//*아웃 위치*/
}
```

- 클래스 타입 파라미터 T 앞에 out 키워드를 붙이면 클래스 안에서 T를 사용하는 메서드가 아웃 위치에서만 T를 사용하게 허용하고 인 위치에서는 T를 사용하지 못하게 막는다.
    - 이는 클래스가 T 타입의 값을 생산할 수는 있지만 T 타입의 값을 소비할 수는 없다는 뜻이다.
    - out 키워드는 T의 사용법을 제한하며 T로 인해 생기는 하위 타입 관계의 타입 안정성을 보장한다.

예를 들어 Herd 클래스를 생각해보자. 

```kotlin
class Herd<T : Animal> {
    operator fun get(i: Int): T { ... }
}
```

- Herd에서 타입 파라미터 T를 사용하는 장소는 오직 get 메서드의 반환 타입뿐이다.
- 따라서 이 클래스를 공변적으로 선언해도 안전하다.
- Cat이 Animal의 하위 타입이기 때문에 Herd<Animal>의 get을 호출하는 모든 코드는 get이 Cat을 반환해도 아무 문제없이 작동한다.

정리하자면, 타입 파라미터 T에 붙은 out 키워드는 다음 두 가지를 함께 의미한다.

- **공변성**: 하위 타입 관계가 유지된다. (Producer<Cat>은 Producer<Animal>의 하위 타입이다).
- **사용 제한**: T를 아웃 위치에서만 사용할 수 있다.

이제 List<T> 인터페이스를 보자. 

```kotlin
public interface List<out E> : Collection<E> {
    public operator fun get(index: Int): E\
		...
}
```

코틀린 List는 읽기 전용이다. 따라서 그 안에는 T 타입의 원소를 반환하는 get 메서드는 있지만 리스트에 T 타입의 값을 추가하거나 리스트에 있는 기존 값을 변경하는 메서드는 없다. 따라서 List는 T에 대해 **공변적**이다.

이젠 MutableList<T> 인터페이스를 보자.

```kotlin
public interface MutableList<E> : List<E>, MutableCollection<E> {
    override fun add(element: E): Boolean
		...
}
```

MutableList<T>에는 T를 인자로 받아서 그 타입의 값을 반환하는 메서드가 있다. 따라서 타입 파라미터 T에 대해 공변적인 클래스로 선언할 수는 없다. 그 이유는 위에서 설명했다.

참고로 생성자 파라미터는 인이나 아웃 어느 쪽도 아니라는 사실에 유의하자.

- 생성자는 인스턴스를 생성한 뒤 호출할 수 있는 메서드가 아니다. 따라서 위험할 여지가 없다.
- 하지만 val 이나 var 키워드를 생성자 파라미터에 적는다면 getter나 setter를 정의하는 것과 같다. 따라서 읽기 전용 프로퍼티(val)은 아웃 위치, 변경 가능 프로퍼티(var)은 아웃과 인 위치 모두에 해당한다.
    
    ```kotlin
    class Herd<out T : Animal>(
        val leadAnimal: T, // getter 는 아웃 위치에 해당하므로 가능하다.
        var leadAnimal: T  // setter 는 인 위치에 해당하므로 컴파일 에러가 발생한다.
    )
    ```
    

## 4) 반공변성: 뒤집힌 하위 타입 관계

반공변성 클래스의 하위 타입 관계는 공변 클래스의 경우와 반대다.

Comsumer<T>를 예로 들어 설명하자.

타입 B가 타입 A의 하위 타입인 경우 Consumer<A>가 Consumer<B>의 하위 타입인 관계가 성립하면 제네릭 클래스 Consumer<T>는 타입 인자 T에 대해 **반공변**이다. 공변의 하위 타입 관계와는 반대라는 점을 확인할 수 있다.

in이라는 키워드는 그 키워드가 붙은 타입이 이 클래스의 메서드 안(in 위치)으로 전달돼 메서드에 의해 소비된다는 뜻이다. 공변성과 마찬가지로 타입 파라미터의 사용을 제한함으로써 특정 하위 타입 관계에 도달할 수 있다.

| 공변성 | 반공변성 | 무공변성 |
| --- | --- | --- |
| Producer<out T> | Consumer<in T> | MutableList<T> |
| 타입 인자의 하위 타입 관계가 제네릭 타입에서도 유지된다. | 타입 인자의 하위 타입 관계가 제네릭 타입에서 뒤집힌다. | 하위 타입 관계가 성립하지 않는다. |
| Producer<Cat>은 Producer<Animal>의 하위 타입이다. | Consumer<Animal>은 Consumer<Cat>의 하위 타입이다. |  |
| T를 아웃 위치에서만 사용할 수 있다. | T를 인 위치에서만 사용할 수 있다. | T를 아무 위치에서나 사용할 수 있다. |

클래스나 인터페이스가 어떤 타입 파라미터에 대해서는 공변적이면서 다른 타입 파라미터에 대해서는 반공변적일 수도 있다. Function 인터페이스가 고전적인 예다.

```kotlin
interface Function(in P, out R) {
		operator fun invoke(p: P): R
}
```

- P와 R에 각각 in과 out 표시가 붙어 있음을 볼 수 있다.
- 이는 첫 번째 타입 인자의 하위 타입 관계와는 정반대지만, 두 번째 타입 인자는 하위 타입 관계와 같음을 뜻한다.

## 5) 사용 지점 변성: 타입이 언급되는 지점에서 변성 지정

- 코틀린은 클래스를 선언하면서 변성을 지정하면 그 클래스를 사용하는 모든 장소에 변성 지정자가 영향을 끼치므로 편리하다. 이런 방식을 **선언 지점 변성**이라 부른다.
- 자바의 와일드카드 타입(? extends나 ? super)에 익숙하다면 자바는 변성을 다른 방식으로 다룬다는 점을 깨달았을 것이다. 자바에서는 타입 파라미터가 있는 타입을 사용할 때마다 해당 타입 파라미터를 하위 타입이나 상위 타입 중 어떤 타입으로 대치할 수 있는지 명시해야 한다. 이런 방식을 **사용 지점 변성**이라 부른다.

<aside>
💡 **코틀린 선언 지점 변성과 자바 와일드카드 비교**
선언 지점 변성을 사용하면 변성 변경자를 단 한 번만 표시하고 클래스를 쓰는 쪽에서는 변성에 대해 신경을 쓸 필요가 없으므로 코드가 더 간결해진다.

</aside>

코틀린도 사용 지점 변성을 지원한다. 따라서 클래스 안에서 어떤 타입 파라미터가 공변적이거나 반공변적인지 선언할 수 없는 경우에도 특정 타입 파라미터가 나타나는 지점에서 변성을 정할 수 있다.

사용 예제를 살펴보자.

**무공변 파라미터 타입을 사용하는 데이터 복사 함수**

```kotlin
fun <T> copyData(source: MutableList<T>, destination: MutableList<T>) {
    for(item in source) {
        destination.add(item)
    }
}
```

- 이 함수는 컬렉션의 원소를 다른 컬렉션으로 복사한다.
- 두 컬렉션 모두 무공변 타입이지만 원본 컬렉션에서는 읽기만 하고 대상 컬렉션에는 쓰기만 한다.
- 이 경우 두 컬렉션의 원소 타입이 정확하게 일치할 필요가 없다.
- 예를 들어 문자열이 원소인 컬렉션에서 객체의 컬렉션으로 원소를 복사해도 아무 문제가 없다.
- 이 코드는 동작하지 않는다. 두 리스트의 타입이 완전 동일하지 않으면 컴파일 에러가 발생한다.

**타입 파라미터가 둘인 데이터 복사 함수**

```kotlin
fun <T: R, R> copyData(
				// source 원소 타입은 destination 원소 타입의 하위 타입이어야 한다.
				source: MutableList<T>,
				destination: MutableList<R> ) {
    for(item in source) {
        destination.add(item)
    }
}

val s = mutableListOf<Int>()
val d = mutableListOf<Any>()
copyData(s, d)
```

- 이 함수는 여러 다른 리스트 타입에 대해 작동하게 할 수 있다.
- 한 리스트에서 다른 리스트로 원소를 복사할 수 있으려면 원본 리스트 원소 타입은 대상 리스트 원소 타입의 하위 타입이어야 한다.
- Int는 Any의 하위 타입이기 때문에 위 코드는 컴파일 에러가 발생하지 않는다.

**아웃-프로젝션 타입 파라미터를 사용하는 데이터 복사 함수**

```kotlin
fun <T> copyData(source: MutableList<out T>, destination: MutableList<T>) {
    for(item in source) {
        destination.add(item)
    }
}
```

- 위처럼 타입 선언에서 타입 파라미터를 사용하는 위치라면 어디에나 변성 변경자를 붙일 수 있다.
- 따라서 파라미터 타입, 로컬 변수 타입, 함수 반환 타입 등에 타입 파라미터가 쓰이는 경우 in이나 out 변경자를 붙일 수 있다.
- 이때 타입 프로젝션이 일어난다.
- 이 경우 MutableList의 메서드 중에서 반환 타입으로 타입 파라미터  T를 사용하는 메서드만 호출할 수 있다. (더 정확하게는 타입 파라미터 T를 아웃 위치에서 사용하는 메서드만 호출할 수 있다.)
- 컴파일러는 타입 파라미터 T를 함수 인자 타입(정확하게는 인 위치에 있는 타입)로 사용하지 못하게 막는다.
- **out을 붙이면 그 파라미터를 더 하위 타입으로 대치할 수 있다.**
    
    ```kotlin
    val list: MutableList<out Number>
    list.add(1)   // 컴파일 에러 발생
    ```
    

**인-프로젝션 타입 파라미터를 사용하는 데이터 복사 함수**

```kotlin
fun <T> copyData(source: MutableList<T>, destination: MutableList<in T>) {
    for(item in source) {
        destination.add(item)
    }
}
```

- **in을 붙이면 그 파라미터를 더 상위 타입으로 대치할 수 있다.**

## 6) 스타 프로젝션: 타입 인자 대신 * 사용

스타 프로젝션은 제네릭 타입 인자 정보가 없음을 표현하기 위해 사용한다.

MutableList<*>는 MutableList<Any?>와 같지 않다.

MutableList<Any?>는 모든 타입의 원소를 담을 수 있다는 사실을 알 수 있는 리스트다. 반면 MutableList<*>는 어떤 정해진 구체적인 타입의 원소만을 리스트지만 그 원소의 타입을 정확히 모른다는 사실을 표현하기 때문이다.

```kotlin
val unknownElement: MutableList<*> = mutableListOf<Int>()
unknownElement.add(1) // 컴파일 에러 발생
```

- 위 코드는 컴파일 에러가 발생한다.
- 컴파일러는 MutableList<*>를 아웃 프로젝션 타입으로 인식한다. 이 맥락에서 Mutable<*>은 Mutable<out Any?>처럼 동작한다는 뜻이다.
- 그 이유는 어떤 리스트의 원소 타입을 모르더라도 그 리스트에서 안전하게 Any? 타입의 원소를 꺼내올 수는 있지만 타입을 모르는 리스트에 원소를 마음대로 넣을 수는 없기 때문이다.
